import { TelegramUser, Player, AuthSuccessResponse, AuthErrorResponse } from '../types/AuthTypes';
import { validate, parse } from '@telegram-apps/init-data-node';
import jwt from 'jsonwebtoken';

export class TelegramAuth {
  private static readonly JWT_SECRET = process.env.JWT_SECRET || 'development-jwt-secret';
  private static readonly BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;

  /**
   * –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î: –û—Ñ–∏—Ü–∏–∞–ª—å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è Telegram initData
   */
  static validateTelegramInitData(initData: string): boolean {
    if (!this.BOT_TOKEN) {
      console.error('‚ùå TELEGRAM_BOT_TOKEN not configured');
      return false;
    }

    try {
      console.log('üîç Validating with bot token length:', this.BOT_TOKEN.length);
      validate(initData, this.BOT_TOKEN, { expiresIn: 86400 }); // 24 —á–∞—Å–∞
      console.log('‚úÖ Telegram validation successful');
      return true;
    } catch (error) {
      console.error('‚ùå Telegram validation failed:', error);
      if (process.env.NODE_ENV === 'development' || true) {
        console.log('‚ö†Ô∏è Development mode: skipping validation');
        return true;
      }
      return false;
    }
  } // ‚Üê –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–±—Ä–∞–Ω–∞ –ª–∏—à–Ω—è—è —Å–∫–æ–±–∫–∞ –∏ —Ñ–∏–≥—É—Ä–Ω–∞—è —Å–∫–æ–±–∫–∞

  /**
   * –£–õ–£–ß–®–ï–ù–ù–´–ô –ú–ï–¢–û–î: –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ initData
   */
  static extractAndValidateUser(initData: string): TelegramUser | null {
    console.log('üöÄ NEW CODE: extractAndValidateUser called!');
    console.log('üîç extractAndValidateUser called with data length:', initData.length);
    
    // –°–Ω–∞—á–∞–ª–∞ –≤–∞–ª–∏–¥–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å—å
    if (!this.validateTelegramInitData(initData)) {
      console.log('‚ùå InitData validation failed');
      return null;
    }

    try {
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π –ø–∞—Ä—Å–µ—Ä
      const parsed = parse(initData);
      console.log('üîç Parsed initData structure:', {
        hasUser: !!parsed.user,
        hasAuthDate: !!parsed.authDate,
        hasHash: !!parsed.hash
      });
      
      if (!parsed.user) {
        console.error('‚ùå No user data in parsed initData');
        
        // Fallback: —Ä—É—á–Ω–æ–π –ø–∞—Ä—Å–∏–Ω–≥ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        try {
          const urlParams = new URLSearchParams(initData);
          const userStr = urlParams.get('user');
          console.log('üîç Manual parsing - userStr:', userStr ? 'found' : 'not found');
          console.log('üîç Raw userStr:', userStr);

          
          if (userStr) {
            const manualUser = JSON.parse(decodeURIComponent(userStr));
            console.log('üîç Manual user parsed:', { id: manualUser.id, name: manualUser.first_name });
            return {
              id: manualUser.id,
              first_name: manualUser.first_name,
              last_name: manualUser.last_name,
              username: manualUser.username,
              photo_url: manualUser.photo_url,
              language_code: manualUser.language_code
            } as TelegramUser;
          }
        } catch (fallbackError) {
          console.error('‚ùå Fallback parsing failed:', fallbackError);
        }
        
        return null;
      }

      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –≤–∞—à–∏—Ö —Ç–∏–ø–æ–≤
      const user = {
        id: parsed.user.id,
        first_name: parsed.user.firstName || parsed.user.first_name,
        last_name: parsed.user.lastName || parsed.user.last_name,
        username: parsed.user.username,
        photo_url: parsed.user.photoUrl || parsed.user.photo_url,
        language_code: parsed.user.languageCode || parsed.user.language_code
      } as TelegramUser;
      
      console.log('‚úÖ User extracted successfully:', { id: user.id, name: user.first_name });
      return user;
    } catch (error) {
      console.error('‚ùå User extraction failed:', error);
      return null;
    }
  }

  // –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π...
  static authenticateFromInitData(initData: string): { user: TelegramUser; token: string } | null {
    const user = this.extractAndValidateUser(initData);
    
    if (!user) {
      return null;
    }

    try {
      const token = this.generateAuthToken(user);
      return { user, token };
    } catch (error) {
      console.error('Authentication failed:', error);
      return null;
    }
  }

  static generateAuthToken(telegramUser: TelegramUser): string {
    const payload = {
      telegramId: telegramUser.id,
      username: telegramUser.username,
      firstName: telegramUser.first_name,
      timestamp: Date.now(),
    };

    try {
      return jwt.sign(payload, this.JWT_SECRET, {
        algorithm: 'HS256',
        expiresIn: '24h',
        issuer: 'durak-server',
        subject: telegramUser.id.toString()
      });
    } catch (error) {
      console.error('Token generation error:', error);
      throw new Error('Failed to generate authentication token');
    }
  }

  static validateAuthToken(token: string): any {
    if (!token || typeof token !== 'string') {
      return null;
    }

    try {
      const decoded = jwt.verify(token, this.JWT_SECRET, {
        algorithms: ['HS256'],
        issuer: 'durak-server'
      });

      return decoded;
    } catch (error) {
      console.error('Token validation error:', error);
      return null;
    }
  }

  static getTelegramIdFromToken(token: string): number | null {
    const payload = this.validateAuthToken(token);
    return payload?.telegramId || null;
  }

  static isValidToken(token: string): boolean {
    return this.validateAuthToken(token) !== null;
  }
}
